name: SLSA Level 3 Build with Integrated VEX Pipeline

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test-and-scan:
    runs-on: ubuntu-latest
    outputs:
      sbom-hash: ${{ steps.sbom.outputs.hash }}
      base-scan-results: ${{ steps.upload-scan.outputs.artifact-id }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: "1.7.1"
        virtualenvs-create: true
        virtualenvs-in-project: true
    
    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v4
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
    
    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction
    
    - name: Verify lock file integrity
      run: poetry check --lock 
    
    - name: Run tests
      run: poetry run pytest tests/ -v 
    
    - name: Run linters and security checks
      run: |
        poetry run black --check src/ tests/
        poetry run mypy src/
        poetry run pip-audit --format=json --output=audit-results.json
    
    - name: Generate SBOM with enhanced metadata
      id: sbom
      run: |
        poetry run python scripts/generate_sbom.py > sbom.json
        echo "hash=$(sha256sum sbom.json | cut -d' ' -f1)" >> $GITHUB_OUTPUT
        
    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom-${{ github.sha }}
        path: sbom.json
        retention-days: 90

    # Initial vulnerability scan to establish baseline
    - name: Run baseline Trivy scan
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'json'
        output: 'baseline-scan.json'

    - name: Upload baseline scan results
      id: upload-scan
      uses: actions/upload-artifact@v4
      with:
        name: baseline-scan-${{ github.sha }}
        path: baseline-scan.json
        retention-days: 30

  build-container:
    needs: test-and-scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-uri: ${{ steps.meta.outputs.tags }}
      
    steps:
    - uses: actions/checkout@v4
    
    - name: Install Cosign
      uses: sigstore/cosign-installer@v3
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=semver,pattern={{version}}
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
        provenance: false  # We'll generate SLSA provenance separately
    
    - name: Sign container image with private key
      env:
        COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
      run: |
        cosign sign --yes --key env://COSIGN_PRIVATE_KEY ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
    
    - name: Generate GitHub Attestations
      uses: actions/attest-build-provenance@v1
      id: attest
      with:
        subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        subject-digest: ${{ steps.build.outputs.digest }}

  vulnerability-analysis-with-vex:
    needs: [build-container, test-and-scan]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      packages: read
    outputs:
      consolidated-vex: ${{ steps.upload-vex.outputs.artifact-id }}
    steps:
    - uses: actions/checkout@v4
    
    # Add registry authentication for VEX operations
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
    
    # Note: Organization package write permissions
    - name: Check VEX attestation permissions
      run: |
        echo "📋 VEX Attestation Setup Information:"
        echo "   For organization repositories, VEX attestations require:"
        echo "   1. Organization-level package write permissions"
        echo "   2. GHCR_PAT secret with 'write:packages' scope (recommended)"
        echo "   3. Or organization settings allowing GitHub Actions package writes"
        echo ""
        if [ -n "${{ secrets.GHCR_PAT }}" ]; then
          echo "✅ GHCR_PAT is configured - using for enhanced permissions"
        else
          echo "⚠️  GHCR_PAT not found - using GITHUB_TOKEN (may have limited org permissions)"
          echo "   Consider adding GHCR_PAT secret for better compatibility"
        fi
    
    # Install vexctl for VEX operations
    - name: Install vexctl
      uses: openvex/setup-vexctl@main
      with:
        vexctl-release: '0.3.0'
    
    - name: Download SBOM
      uses: actions/download-artifact@v4
      with:
        name: sbom-${{ github.sha }}
    
    - name: Download baseline scan
      uses: actions/download-artifact@v4
      with:
        name: baseline-scan-${{ github.sha }}
    
    # Verify image accessibility before scanning
    - name: Verify image accessibility
      run: |
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
        echo "🔍 Verifying image accessibility: $IMAGE_REF"
        
        # Try to inspect the image to ensure it's accessible
        docker manifest inspect "$IMAGE_REF" || {
          echo "❌ Cannot access image manifest. Checking if image exists..."
          docker pull "$IMAGE_REF" || {
            echo "❌ Cannot pull image. This may cause VEX attestation to fail."
            exit 1
          }
        }
        echo "✅ Image is accessible"
    
    # Scan the built container image
    - name: Run Trivy vulnerability scanner on image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}
        format: 'json'
        output: 'container-scan.json'
    
    - name: Run Trivy on SBOM
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'sbom'
        scan-ref: 'sbom.json'
        format: 'sarif'
        output: 'trivy-sbom-results.sarif'

    # Collect existing VEX documents from production/previous runs
    - name: Collect existing VEX documents
      run: |
        echo "🔍 Collecting existing VEX documents from repository..."
        mkdir -p vex-sources
        
        # Find all VEX documents in the repository
        find . -name "*.vex.json" -not -path "./vex-sources/*" -exec cp {} vex-sources/ \;
        
        # List found VEX documents
        if [ -d "vex-sources" ] && [ "$(ls -A vex-sources)" ]; then
          echo "📄 Found existing VEX documents:"
          ls -la vex-sources/
        else
          echo "📄 No existing VEX documents found"
          touch vex-sources/.keep
        fi

    # Generate initial VEX from current scan results
    - name: Generate build-time VEX document
      run: |
        echo "🔧 Generating build-time VEX document..."
        python scripts/generate_vex.py \
          --trivy-results container-scan.json \
          --sbom sbom.json \
          --output build-time.vex.json
        
        echo "📄 Generated build-time VEX:"
        jq '.vulnerabilities | length' build-time.vex.json || echo "0"

    # Consolidate all VEX documents using vexctl
    - name: Consolidate VEX documents
      run: |
        echo "🔄 Consolidating VEX documents using vexctl..."
        
        # Start with build-time VEX
        cp build-time.vex.json consolidated.vex.json
        
        # Merge existing VEX documents if any exist
        if [ -d "vex-sources" ] && [ "$(ls -A vex-sources/*.vex.json 2>/dev/null)" ]; then
          echo "🔗 Merging with existing VEX documents..."
          for vex_file in vex-sources/*.vex.json; do
            if [ -f "$vex_file" ]; then
              echo "  📄 Merging: $(basename $vex_file)"
              # Use vexctl to merge VEX documents
              vexctl merge \
                --product="pkg:oci/${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}" \
                consolidated.vex.json \
                "$vex_file" > temp.vex.json
              mv temp.vex.json consolidated.vex.json
            fi
          done
        else
          echo "📄 No existing VEX documents to merge"
        fi
        
        echo "✅ Consolidation complete. Final VEX document:"
        jq '.statements | length' consolidated.vex.json || echo "0 statements"

    # Apply VEX to filter scan results
    - name: Apply VEX filtering to scan results
      run: |
        echo "🔽 Applying VEX filtering to scan results..."
        
        # Convert Trivy JSON to SARIF for vexctl filtering
        trivy convert --format sarif --output unfiltered.sarif container-scan.json
        
        # Apply VEX filtering using vexctl
        vexctl filter unfiltered.sarif consolidated.vex.json > filtered.sarif
        
        # Show filtering results
        echo "📊 VEX Filtering Results:"
        UNFILTERED_COUNT=$(jq '.runs[0].results | length' unfiltered.sarif 2>/dev/null || echo "0")
        FILTERED_COUNT=$(jq '.runs[0].results | length' filtered.sarif 2>/dev/null || echo "0")
        FILTERED_OUT=$((UNFILTERED_COUNT - FILTERED_COUNT))
        
        echo "  🔍 Original vulnerabilities: $UNFILTERED_COUNT"
        echo "  ✅ Remaining after VEX: $FILTERED_COUNT"
        echo "  🚫 Filtered out by VEX: $FILTERED_OUT"
        
        # Create summary for PR comments
        cat > vex-summary.md << EOF
        ## 🛡️ VEX Filtering Summary
        
        | Metric | Count |
        |--------|-------|
        | Original vulnerabilities | $UNFILTERED_COUNT |
        | Remaining after VEX filtering | $FILTERED_COUNT |
        | **Filtered out by VEX** | **$FILTERED_OUT** |
        
        VEX documents successfully reduced the vulnerability report by **$FILTERED_OUT** entries.
        EOF

    # Upload filtered SARIF results to GitHub Security
    - name: Upload filtered SARIF results to GitHub Security
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'filtered.sarif'
        category: 'trivy-vex-filtered'

    # Upload VEX documents and results
    - name: Upload consolidated VEX document
      id: upload-vex
      uses: actions/upload-artifact@v4
      with:
        name: consolidated-vex-${{ github.sha }}
        path: |
          consolidated.vex.json
          vex-summary.md
          filtered.sarif
          unfiltered.sarif
          vex-attestation.jsonl
          vex-attestation-instructions.md
        retention-days: 90

    # Store VEX attestation as artifact and optionally attach to image
    - name: Attest VEX document to container image
      env:
        COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        # Use PAT if available for organization package writes, otherwise use GITHUB_TOKEN
        REGISTRY_TOKEN: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
      run: |
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
        echo "🔐 Attesting VEX document to container image: $IMAGE_REF"
        
        # Ensure we have a valid VEX document
        if [ ! -f "consolidated.vex.json" ]; then
          echo "❌ consolidated.vex.json not found"
          exit 1
        fi
        
        # Validate VEX document structure
        echo "🔍 Validating VEX document..."
        jq empty consolidated.vex.json || {
          echo "❌ Invalid VEX JSON document"
          exit 1
        }
        
        # Create a signed VEX attestation file
        echo "🔏 Creating signed VEX attestation..."
        cosign attest \
          --yes \
          --key env://COSIGN_PRIVATE_KEY \
          --type=openvex \
          --predicate=consolidated.vex.json \
          --output-file=vex-attestation.jsonl \
          "$IMAGE_REF" || {
          
          echo "⚠️  Direct image attestation failed (likely due to organization permissions)"
          echo "📄 Creating standalone signed VEX attestation instead..."
          
          # Create a standalone attestation that can be verified later
          cosign attest \
            --yes \
            --key env://COSIGN_PRIVATE_KEY \
            --type=openvex \
            --predicate=consolidated.vex.json \
            --output-file=vex-attestation.jsonl \
            --no-upload \
            "$IMAGE_REF"
          
          echo "✅ Standalone VEX attestation created successfully"
          echo "📋 To attach this attestation later with proper permissions:"
          echo "   cosign attach attestation --attestation vex-attestation.jsonl $IMAGE_REF"
          
          # Create instructions for manual attachment
          cat > vex-attestation-instructions.md << EOF
        # VEX Attestation Instructions
        
        The VEX attestation was created but could not be automatically attached due to organization permissions.
        
        ## To attach the attestation manually:
        
        1. Download the \`vex-attestation.jsonl\` file from the workflow artifacts
        2. Run the following command with appropriate permissions:
        
        \`\`\`bash
        cosign attach attestation --attestation vex-attestation.jsonl $IMAGE_REF
        \`\`\`
        
        ## To verify the standalone attestation:
        
        \`\`\`bash
        cosign verify-attestation --type=openvex --key cosign.pub $IMAGE_REF
        \`\`\`
        
        ## Image Reference:
        \`$IMAGE_REF\`
        EOF
          
          exit 0
        }
        
        echo "✅ VEX attestation attached to image successfully"

  # Modified runtime VEX generation job
  runtime-vex-generation:
    needs: [build-container, vulnerability-analysis-with-vex]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      packages: read
    outputs:
      runtime-vex-generated: ${{ steps.runtime-vex.outputs.generated }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install vexctl
        uses: openvex/setup-vexctl@main
        with:
          vexctl-release: '0.3.0'

      - name: Create Kubernetes Kind Cluster
        id: kind
        uses: helm/kind-action@v1
        with:
          cluster_name: feelgood-cluster
          wait: 60s
          verbosity: 1

      - name: Verify cluster is ready
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Install Kubescape Operator with VEX Generation
        run: |
          echo "🔧 Installing Kubescape Operator with VEX generation enabled..."
          helm repo add kubescape https://kubescape.github.io/helm-charts/
          helm repo update
          
          # Install Kubescape with VEX generation enabled
          helm upgrade --install kubescape kubescape/kubescape-operator \
            -n kubescape \
            --create-namespace \
            --set clusterName=feelgood-cluster \
            --set capabilities.vexGeneration=enable \
            --set capabilities.vulnerabilityScan=enable \
            --set capabilities.relevancy=enable \
            --set capabilities.runtimeObservability=enable \
            --wait \
            --timeout=300s

      - name: Verify Kubescape deployment
        run: |
          echo "🔍 Verifying Kubescape pods are running..."
          kubectl get pods -n kubescape
          kubectl wait --for=condition=ready pod --all -n kubescape --timeout=300s

      - name: Deploy application with consolidated VEX
        run: |
          IMAGE_TAG="latest"
          FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
          
          echo "🚀 Deploying image: $FULL_IMAGE"
          
          cat <<EOF > app-deployment.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ github.event.repository.name }}
            labels:
              app: ${{ github.event.repository.name }}
              vex-enabled: "true"
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ github.event.repository.name }}
            template:
              metadata:
                labels:
                  app: ${{ github.event.repository.name }}
                annotations:
                  vex.openvex.dev/available: "true"
              spec:
                containers:
                - name: ${{ github.event.repository.name }}
                  image: ${FULL_IMAGE}
                  imagePullPolicy: Always
                  ports:
                  - containerPort: 8000 
                  env:
                  - name: PORT
                    value: "8000"
                  - name: ENV
                    value: "production"
                  resources:
                    requests:
                      memory: "64Mi"
                      cpu: "50m"
                    limits:
                      memory: "256Mi"
                      cpu: "200m"
                  securityContext:
                    runAsNonRoot: true
                    runAsUser: 65534
                    allowPrivilegeEscalation: false
                    capabilities:
                      drop:
                      - ALL
                    readOnlyRootFilesystem: true
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ github.event.repository.name }}-service
          spec:
            type: NodePort
            ports:
            - port: 80
              targetPort: 8000
              nodePort: 30080
              protocol: TCP
            selector:
              app: ${{ github.event.repository.name }}
          EOF

          kubectl apply -f app-deployment.yaml
          kubectl wait --for=condition=available --timeout=300s deployment/${{ github.event.repository.name }}

      - name: Generate runtime load for VEX analysis
        run: |
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          echo "🔄 Generating runtime activity for better VEX analysis..."
          
          # Generate some load to trigger runtime analysis
          for i in {1..30}; do
            curl -s http://$NODE_IP:30080 > /dev/null 2>&1 || true
            sleep 2
          done

      - name: Wait for runtime VEX generation
        run: |
          echo "⏳ Waiting for Kubescape to generate runtime VEX documents..."
          echo "🕐 Start time: $(date)"
          
          # Wait for VEX documents with timeout
          for i in {1..5}; do
            echo "⏱️  Minute $i/5 - $(date)"
            
            VEX_COUNT=$(kubectl get openvulnerabilityexchangecontainer -n kubescape 2>/dev/null | wc -l || echo "0")
            if [ "$VEX_COUNT" -gt 1 ]; then
              echo "📄 Found $((VEX_COUNT-1)) runtime VEX document(s)"
              break
            else
              echo "📄 No VEX documents generated yet..."
            fi
            
            sleep 60
          done

      - name: Extract and merge runtime VEX
        id: runtime-vex
        run: |
          echo "📊 Extracting runtime VEX documents..."
          
          VEX_RESOURCES=$(kubectl get openvulnerabilityexchangecontainer -n kubescape --no-headers 2>/dev/null || echo "")
          
          if [ -z "$VEX_RESOURCES" ]; then
            echo "⚠️  No runtime VEX documents found"
            echo "generated=false" >> $GITHUB_OUTPUT
          else
            echo "✅ Found runtime VEX documents"
            
            # Extract the first VEX document
            FIRST_VEX=$(kubectl get openvulnerabilityexchangecontainer -n kubescape --no-headers | head -1 | awk '{print $1}')
            kubectl get openvulnerabilityexchangecontainer "$FIRST_VEX" -n kubescape -o jsonpath='{.spec}' > runtime.vex.json
            
            # Download consolidated VEX from previous job
            # Note: In a real workflow, you'd download the artifact here
            # For now, we'll create a placeholder for the merge operation
            
            echo "🔄 Would merge runtime VEX with build-time VEX here"
            echo "📄 Runtime VEX saved as runtime.vex.json"
            echo "generated=true" >> $GITHUB_OUTPUT
          fi

      - name: Upload runtime VEX
        if: steps.runtime-vex.outputs.generated == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: runtime-vex-${{ github.sha }}
          path: runtime.vex.json
          retention-days: 30

  slsa-provenance:
    needs: build-container
    if: github.event_name != 'pull_request'
    permissions:
      actions: read
      id-token: write
      packages: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v2.0.0
    with:
      image: ghcr.io/${{ github.repository }}
      digest: ${{ needs.build-container.outputs.image-digest }}
      registry-username: ${{ github.actor }}
    secrets:
      registry-password: ${{ secrets.GITHUB_TOKEN }}

  verify-attestations:
    needs: [build-container, slsa-provenance, vulnerability-analysis-with-vex]
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Install Cosign
      uses: sigstore/cosign-installer@v3
      
    - name: Install SLSA Verifier
      uses: slsa-framework/slsa-verifier/actions/installer@v2.5.1

    - name: Install vexctl
      uses: openvex/setup-vexctl@main
      with:
        vexctl-release: '0.3.0'
    
    - name: Verify container signature and SLSA provenance
      run: |
        # Verify signature
        cosign verify --key cosign.pub \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}
        
        # Verify SLSA provenance
        slsa-verifier verify-image \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }} \
          --source-uri github.com/${{ github.repository }}

    - name: Verify VEX attestation
      run: |
        echo "🔍 Verifying VEX attestation..."
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
        
        # Try to verify attached attestation first
        if cosign verify-attestation \
          --key cosign.pub \
          --type=openvex \
          "$IMAGE_REF" 2>/dev/null; then
          echo "✅ VEX attestation verified on image"
        else
          echo "⚠️  No attached VEX attestation found on image"
          echo "📄 This may be due to organization permissions"
          echo "🔍 VEX attestation was created as standalone artifact"
          echo "📋 Check workflow artifacts for vex-attestation.jsonl and instructions"
        fi

  # Summary job for PR comments
  vex-summary:
    needs: [vulnerability-analysis-with-vex, runtime-vex-generation]
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
    - name: Download VEX summary
      uses: actions/download-artifact@v4
      with:
        name: consolidated-vex-${{ github.sha }}

    - name: Comment VEX summary on PR
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          try {
            const summary = fs.readFileSync('vex-summary.md', 'utf8');
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
          } catch (error) {
            console.log('Could not read VEX summary:', error);
          }
