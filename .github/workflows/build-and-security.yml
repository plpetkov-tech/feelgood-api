name: SLSA Level 3 Build with Integrated VEX Pipeline

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test-and-scan:
    runs-on: ubuntu-latest
    outputs:
      sbom-hash: ${{ steps.sbom.outputs.hash }}
      base-scan-results: ${{ steps.upload-scan.outputs.artifact-id }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: "1.7.1"
        virtualenvs-create: true
        virtualenvs-in-project: true
    
    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v4
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
    
    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction
    
    - name: Verify lock file integrity
      run: poetry check --lock 
    
    - name: Run tests
      run: poetry run pytest tests/ -v 
    
    - name: Run linters and security checks
      run: |
        poetry run black --check src/ tests/
        poetry run mypy src/
        poetry run pip-audit --format=json --output=audit-results.json
    
    - name: Generate SBOM with enhanced metadata
      id: sbom
      run: |
        poetry run python scripts/generate_sbom.py > sbom.json
        echo "hash=$(sha256sum sbom.json | cut -d' ' -f1)" >> $GITHUB_OUTPUT
        
    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom-${{ github.sha }}
        path: sbom.json
        retention-days: 90

    # Initial vulnerability scan to establish baseline
    - name: Run baseline Trivy scan
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'json'
        output: 'baseline-scan.json'

    - name: Upload baseline scan results
      id: upload-scan
      uses: actions/upload-artifact@v4
      with:
        name: baseline-scan-${{ github.sha }}
        path: baseline-scan.json
        retention-days: 30

  build-container:
    needs: test-and-scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-uri: ${{ steps.meta.outputs.tags }}
      
    steps:
    - uses: actions/checkout@v4
    
    - name: Install Cosign
      uses: sigstore/cosign-installer@v3
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=semver,pattern={{version}}
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
        provenance: false  # We'll generate SLSA provenance separately
    
    - name: Sign container image with private key
      env:
        COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
      run: |
        cosign sign --yes --key env://COSIGN_PRIVATE_KEY ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
    
    - name: Generate GitHub Attestations
      uses: actions/attest-build-provenance@v1
      id: attest
      with:
        subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        subject-digest: ${{ steps.build.outputs.digest }}

  vulnerability-analysis-with-vex:
    needs: [build-container, test-and-scan]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      packages: read
    outputs:
      consolidated-vex: ${{ steps.upload-vex.outputs.artifact-id }}
    steps:
    - uses: actions/checkout@v4
    
    # Add registry authentication for VEX operations
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    # Install vexctl for VEX operations
    - name: Install vexctl
      uses: openvex/setup-vexctl@main
      with:
        vexctl-release: '0.3.0'
    
    - name: Download SBOM
      uses: actions/download-artifact@v4
      with:
        name: sbom-${{ github.sha }}
    
    - name: Download baseline scan
      uses: actions/download-artifact@v4
      with:
        name: baseline-scan-${{ github.sha }}
    
    # Verify image accessibility before scanning
    - name: Verify image accessibility
      run: |
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
        echo "üîç Verifying image accessibility: $IMAGE_REF"
        
        # Try to inspect the image to ensure it's accessible
        docker manifest inspect "$IMAGE_REF" || {
          echo "‚ùå Cannot access image manifest. Checking if image exists..."
          docker pull "$IMAGE_REF" || {
            echo "‚ùå Cannot pull image. This may cause VEX attestation to fail."
            exit 1
          }
        }
        echo "‚úÖ Image is accessible"
    
    # Scan the built container image
    - name: Run Trivy vulnerability scanner on image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}
        format: 'json'
        output: 'container-scan.json'
    
    - name: Run Trivy on SBOM
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'sbom'
        scan-ref: 'sbom.json'
        format: 'sarif'
        output: 'trivy-sbom-results.sarif'

    # Collect existing VEX documents from production/previous runs
    - name: Collect existing VEX documents
      run: |
        echo "üîç Collecting existing VEX documents from repository..."
        mkdir -p vex-sources
        
        # Find all VEX documents in the repository
        find . -name "*.vex.json" -not -path "./vex-sources/*" -exec cp {} vex-sources/ \;
        
        # List found VEX documents
        if [ -d "vex-sources" ] && [ "$(ls -A vex-sources)" ]; then
          echo "üìÑ Found existing VEX documents:"
          ls -la vex-sources/
        else
          echo "üìÑ No existing VEX documents found"
          touch vex-sources/.keep
        fi

    # Generate initial VEX from current scan results
    - name: Generate build-time VEX document
      run: |
        echo "üîß Generating build-time VEX document..."
        python scripts/generate_vex.py \
          --trivy-results container-scan.json \
          --sbom sbom.json \
          --output build-time.vex.json
        
        echo "üìÑ Generated build-time VEX:"
        jq '.vulnerabilities | length' build-time.vex.json || echo "0"

    # Consolidate all VEX documents using vexctl
    - name: Consolidate VEX documents
      run: |
        echo "üîÑ Consolidating VEX documents using vexctl..."
        
        # Start with build-time VEX
        cp build-time.vex.json consolidated.vex.json
        
        # Merge existing VEX documents if any exist
        if [ -d "vex-sources" ] && [ "$(ls -A vex-sources/*.vex.json 2>/dev/null)" ]; then
          echo "üîó Merging with existing VEX documents..."
          for vex_file in vex-sources/*.vex.json; do
            if [ -f "$vex_file" ]; then
              echo "  üìÑ Merging: $(basename $vex_file)"
              # Use vexctl to merge VEX documents
              vexctl merge \
                --product="pkg:oci/${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}" \
                consolidated.vex.json \
                "$vex_file" > temp.vex.json
              mv temp.vex.json consolidated.vex.json
            fi
          done
        else
          echo "üìÑ No existing VEX documents to merge"
        fi
        
        echo "‚úÖ Consolidation complete. Final VEX document:"
        jq '.statements | length' consolidated.vex.json || echo "0 statements"

    # Apply VEX to filter scan results
    - name: Apply VEX filtering to scan results
      run: |
        echo "üîΩ Applying VEX filtering to scan results..."
        
        # Convert Trivy JSON to SARIF for vexctl filtering
        trivy convert --format sarif --output unfiltered.sarif container-scan.json
        
        # Apply VEX filtering using vexctl
        vexctl filter unfiltered.sarif consolidated.vex.json > filtered.sarif
        
        # Show filtering results
        echo "üìä VEX Filtering Results:"
        UNFILTERED_COUNT=$(jq '.runs[0].results | length' unfiltered.sarif 2>/dev/null || echo "0")
        FILTERED_COUNT=$(jq '.runs[0].results | length' filtered.sarif 2>/dev/null || echo "0")
        FILTERED_OUT=$((UNFILTERED_COUNT - FILTERED_COUNT))
        
        echo "  üîç Original vulnerabilities: $UNFILTERED_COUNT"
        echo "  ‚úÖ Remaining after VEX: $FILTERED_COUNT"
        echo "  üö´ Filtered out by VEX: $FILTERED_OUT"
        
        # Create summary for PR comments
        cat > vex-summary.md << EOF
        ## üõ°Ô∏è VEX Filtering Summary
        
        | Metric | Count |
        |--------|-------|
        | Original vulnerabilities | $UNFILTERED_COUNT |
        | Remaining after VEX filtering | $FILTERED_COUNT |
        | **Filtered out by VEX** | **$FILTERED_OUT** |
        
        VEX documents successfully reduced the vulnerability report by **$FILTERED_OUT** entries.
        EOF

    # Upload filtered SARIF results to GitHub Security
    - name: Upload filtered SARIF results to GitHub Security
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'filtered.sarif'
        category: 'trivy-vex-filtered'

    # Upload VEX documents and results
    - name: Upload consolidated VEX document
      id: upload-vex
      uses: actions/upload-artifact@v4
      with:
        name: consolidated-vex-${{ github.sha }}
        path: |
          consolidated.vex.json
          vex-summary.md
          filtered.sarif
          unfiltered.sarif
        retention-days: 90

    # Fixed VEX attestation step
    - name: Attest VEX document to container image
      env:
        COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
      run: |
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
        echo "üîê Attesting VEX document to container image: $IMAGE_REF"
        
        # Ensure we have a valid VEX document
        if [ ! -f "consolidated.vex.json" ]; then
          echo "‚ùå consolidated.vex.json not found"
          exit 1
        fi
        
        # Validate VEX document structure
        echo "üîç Validating VEX document..."
        jq empty consolidated.vex.json || {
          echo "‚ùå Invalid VEX JSON document"
          exit 1
        }
        
        # Use cosign to attest the VEX document instead of vexctl attest
        # This is more reliable and compatible with the existing signing setup
        cosign attest --yes \
          --key env://COSIGN_PRIVATE_KEY \
          --type=vex \
          --predicate=consolidated.vex.json \
          "$IMAGE_REF"
        
        echo "‚úÖ VEX attestation attached to image using cosign"

  # Modified runtime VEX generation job
  runtime-vex-generation:
    needs: [build-container, vulnerability-analysis-with-vex]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      packages: read
    outputs:
      runtime-vex-generated: ${{ steps.runtime-vex.outputs.generated }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install vexctl
        uses: openvex/setup-vexctl@main
        with:
          vexctl-release: '0.3.0'

      - name: Create Kubernetes Kind Cluster
        id: kind
        uses: helm/kind-action@v1
        with:
          cluster_name: feelgood-cluster
          wait: 60s
          verbosity: 1

      - name: Verify cluster is ready
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Install Kubescape Operator with VEX Generation
        run: |
          echo "üîß Installing Kubescape Operator with VEX generation enabled..."
          helm repo add kubescape https://kubescape.github.io/helm-charts/
          helm repo update
          
          # Install Kubescape with VEX generation enabled
          helm upgrade --install kubescape kubescape/kubescape-operator \
            -n kubescape \
            --create-namespace \
            --set clusterName=feelgood-cluster \
            --set capabilities.vexGeneration=enable \
            --set capabilities.vulnerabilityScan=enable \
            --set capabilities.relevancy=enable \
            --set capabilities.runtimeObservability=enable \
            --wait \
            --timeout=300s

      - name: Verify Kubescape deployment
        run: |
          echo "üîç Verifying Kubescape pods are running..."
          kubectl get pods -n kubescape
          kubectl wait --for=condition=ready pod --all -n kubescape --timeout=300s

      - name: Deploy application with consolidated VEX
        run: |
          IMAGE_TAG="latest"
          FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
          
          echo "üöÄ Deploying image: $FULL_IMAGE"
          
          cat <<EOF > app-deployment.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ github.event.repository.name }}
            labels:
              app: ${{ github.event.repository.name }}
              vex-enabled: "true"
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ github.event.repository.name }}
            template:
              metadata:
                labels:
                  app: ${{ github.event.repository.name }}
                annotations:
                  vex.openvex.dev/available: "true"
              spec:
                containers:
                - name: ${{ github.event.repository.name }}
                  image: ${FULL_IMAGE}
                  imagePullPolicy: Always
                  ports:
                  - containerPort: 8000 
                  env:
                  - name: PORT
                    value: "8000"
                  - name: ENV
                    value: "production"
                  resources:
                    requests:
                      memory: "64Mi"
                      cpu: "50m"
                    limits:
                      memory: "256Mi"
                      cpu: "200m"
                  securityContext:
                    runAsNonRoot: true
                    runAsUser: 65534
                    allowPrivilegeEscalation: false
                    capabilities:
                      drop:
                      - ALL
                    readOnlyRootFilesystem: true
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ github.event.repository.name }}-service
          spec:
            type: NodePort
            ports:
            - port: 80
              targetPort: 8000
              nodePort: 30080
              protocol: TCP
            selector:
              app: ${{ github.event.repository.name }}
          EOF

          kubectl apply -f app-deployment.yaml
          kubectl wait --for=condition=available --timeout=300s deployment/${{ github.event.repository.name }}

      - name: Generate runtime load for VEX analysis
        run: |
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          echo "üîÑ Generating runtime activity for better VEX analysis..."
          
          # Generate some load to trigger runtime analysis
          for i in {1..30}; do
            curl -s http://$NODE_IP:30080 > /dev/null 2>&1 || true
            sleep 2
          done

      - name: Wait for runtime VEX generation
        run: |
          echo "‚è≥ Waiting for Kubescape to generate runtime VEX documents..."
          echo "üïê Start time: $(date)"
          
          # Wait for VEX documents with timeout
          for i in {1..5}; do
            echo "‚è±Ô∏è  Minute $i/5 - $(date)"
            
            VEX_COUNT=$(kubectl get openvulnerabilityexchangecontainer -n kubescape 2>/dev/null | wc -l || echo "0")
            if [ "$VEX_COUNT" -gt 1 ]; then
              echo "üìÑ Found $((VEX_COUNT-1)) runtime VEX document(s)"
              break
            else
              echo "üìÑ No VEX documents generated yet..."
            fi
            
            sleep 60
          done

      - name: Extract and merge runtime VEX
        id: runtime-vex
        run: |
          echo "üìä Extracting runtime VEX documents..."
          
          VEX_RESOURCES=$(kubectl get openvulnerabilityexchangecontainer -n kubescape --no-headers 2>/dev/null || echo "")
          
          if [ -z "$VEX_RESOURCES" ]; then
            echo "‚ö†Ô∏è  No runtime VEX documents found"
            echo "generated=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found runtime VEX documents"
            
            # Extract the first VEX document
            FIRST_VEX=$(kubectl get openvulnerabilityexchangecontainer -n kubescape --no-headers | head -1 | awk '{print $1}')
            kubectl get openvulnerabilityexchangecontainer "$FIRST_VEX" -n kubescape -o jsonpath='{.spec}' > runtime.vex.json
            
            # Download consolidated VEX from previous job
            # Note: In a real workflow, you'd download the artifact here
            # For now, we'll create a placeholder for the merge operation
            
            echo "üîÑ Would merge runtime VEX with build-time VEX here"
            echo "üìÑ Runtime VEX saved as runtime.vex.json"
            echo "generated=true" >> $GITHUB_OUTPUT
          fi

      - name: Upload runtime VEX
        if: steps.runtime-vex.outputs.generated == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: runtime-vex-${{ github.sha }}
          path: runtime.vex.json
          retention-days: 30

  slsa-provenance:
    needs: build-container
    if: github.event_name != 'pull_request'
    permissions:
      actions: read
      id-token: write
      packages: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v2.0.0
    with:
      image: ghcr.io/${{ github.repository }}
      digest: ${{ needs.build-container.outputs.image-digest }}
      registry-username: ${{ github.actor }}
    secrets:
      registry-password: ${{ secrets.GITHUB_TOKEN }}

  verify-attestations:
    needs: [build-container, slsa-provenance, vulnerability-analysis-with-vex]
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Install Cosign
      uses: sigstore/cosign-installer@v3
      
    - name: Install SLSA Verifier
      uses: slsa-framework/slsa-verifier/actions/installer@v2.5.1

    - name: Install vexctl
      uses: openvex/setup-vexctl@main
      with:
        vexctl-release: '0.3.0'
    
    - name: Verify container signature and SLSA provenance
      run: |
        # Verify signature
        cosign verify --key cosign.pub \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}
        
        # Verify SLSA provenance
        slsa-verifier verify-image \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }} \
          --source-uri github.com/${{ github.repository }}

    - name: Verify VEX attestation
      run: |
        echo "üîç Verifying VEX attestation..."
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
        
        # Verify VEX attestation was attached using cosign
        cosign verify-attestation \
          --key cosign.pub \
          --type=openvex \
          "$IMAGE_REF"
        
        echo "‚úÖ VEX attestation verified and accessible"

  # Summary job for PR comments
  vex-summary:
    needs: [vulnerability-analysis-with-vex, runtime-vex-generation]
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
    - name: Download VEX summary
      uses: actions/download-artifact@v4
      with:
        name: consolidated-vex-${{ github.sha }}

    - name: Comment VEX summary on PR
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          try {
            const summary = fs.readFileSync('vex-summary.md', 'utf8');
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
          } catch (error) {
            console.log('Could not read VEX summary:', error);
          }