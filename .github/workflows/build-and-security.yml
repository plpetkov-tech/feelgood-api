name: SLSA Level 3 Build with Integrated VEX Pipeline

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test-and-scan:
    runs-on: ubuntu-latest
    outputs:
      sbom-hash: ${{ steps.sbom.outputs.hash }}
      base-scan-results: ${{ steps.upload-scan.outputs.artifact-id }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: "1.7.1"
        virtualenvs-create: true
        virtualenvs-in-project: true
    
    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v4
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
    
    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction
    
    - name: Verify lock file integrity
      run: poetry check --lock 
    
    - name: Run tests
      run: poetry run pytest tests/ -v 
    
    - name: Run linters and security checks
      run: |
        poetry run black --check src/ tests/
        poetry run mypy src/
        poetry run pip-audit --format=json --output=audit-results.json
    
    - name: Generate SBOM with enhanced metadata
      id: sbom
      run: |
        poetry run python scripts/generate_sbom.py > sbom.json
        echo "hash=$(sha256sum sbom.json | cut -d' ' -f1)" >> $GITHUB_OUTPUT
        
    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom-${{ github.sha }}
        path: sbom.json
        retention-days: 90

    # Initial vulnerability scan to establish baseline
    - name: Run baseline Trivy scan
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'json'
        output: 'baseline-scan.json'

    - name: Upload baseline scan results
      id: upload-scan
      uses: actions/upload-artifact@v4
      with:
        name: baseline-scan-${{ github.sha }}
        path: baseline-scan.json
        retention-days: 30

  build-container:
    needs: test-and-scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-uri: ${{ steps.meta.outputs.tags }}
      
    steps:
    - uses: actions/checkout@v4
    
    - name: Install Cosign
      uses: sigstore/cosign-installer@v3
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=semver,pattern={{version}}
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
        provenance: false  # We'll generate SLSA provenance separately
    
    - name: Sign container image with private key
      env:
        COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
      run: |
        cosign sign --yes --key env://COSIGN_PRIVATE_KEY ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
    
    - name: Generate GitHub Attestations
      uses: actions/attest-build-provenance@v1
      id: attest
      with:
        subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        subject-digest: ${{ steps.build.outputs.digest }}

  vulnerability-analysis-with-vex:
    needs: [build-container, test-and-scan]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      packages: read
    outputs:
      consolidated-vex: ${{ steps.upload-vex.outputs.artifact-id }}
    steps:
    - uses: actions/checkout@v4
    
    # Add registry authentication for VEX operations
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
    
    # Note: Organization package write permissions
    - name: Check VEX attestation permissions
      run: |
        echo "ğŸ“‹ VEX Attestation Setup Information:"
        echo "   For organization repositories, VEX attestations require:"
        echo "   1. Organization-level package write permissions"
        echo "   2. GHCR_PAT secret with 'write:packages' scope (recommended)"
        echo "   3. Or organization settings allowing GitHub Actions package writes"
        echo ""
        if [ -n "${{ secrets.GHCR_PAT }}" ]; then
          echo "âœ… GHCR_PAT is configured - using for enhanced permissions"
        else
          echo "âš ï¸  GHCR_PAT not found - using GITHUB_TOKEN (may have limited org permissions)"
          echo "   Consider adding GHCR_PAT secret for better compatibility"
        fi
    
    # Install vexctl for VEX operations
    - name: Install vexctl
      uses: openvex/setup-vexctl@main
      with:
        vexctl-release: '0.3.0'
    
    - name: Download SBOM
      uses: actions/download-artifact@v4
      with:
        name: sbom-${{ github.sha }}
    
    - name: Download baseline scan
      uses: actions/download-artifact@v4
      with:
        name: baseline-scan-${{ github.sha }}
    
    # Verify image accessibility before scanning
    - name: Verify image accessibility
      run: |
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
        echo "ğŸ” Verifying image accessibility: $IMAGE_REF"
        
        # Try to inspect the image to ensure it's accessible
        docker manifest inspect "$IMAGE_REF" || {
          echo "âŒ Cannot access image manifest. Checking if image exists..."
          docker pull "$IMAGE_REF" || {
            echo "âŒ Cannot pull image. This may cause VEX attestation to fail."
            exit 1
          }
        }
        echo "âœ… Image is accessible"
    
    # Scan the built container image
    - name: Run Trivy vulnerability scanner on image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}
        format: 'json'
        output: 'container-scan.json'
    
    - name: Run Trivy on SBOM
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'sbom'
        scan-ref: 'sbom.json'
        format: 'sarif'
        output: 'trivy-sbom-results.sarif'

    # Collect existing VEX documents from production/previous runs
    - name: Collect existing VEX documents
      run: |
        echo "ğŸ” Collecting existing VEX documents from repository..."
        mkdir -p vex-sources
        
        # Find all VEX documents in the repository
        find . -name "*.vex.json" -not -path "./vex-sources/*" -exec cp {} vex-sources/ \;
        
        # List found VEX documents
        if [ -d "vex-sources" ] && [ "$(ls -A vex-sources)" ]; then
          echo "ğŸ“„ Found existing VEX documents:"
          ls -la vex-sources/
        else
          echo "ğŸ“„ No existing VEX documents found"
          touch vex-sources/.keep
        fi

    # Generate initial VEX from current scan results
    - name: Generate build-time VEX document
      run: |
        echo "ğŸ”§ Generating build-time VEX document..."
        python scripts/generate_vex.py \
          --trivy-results container-scan.json \
          --sbom sbom.json \
          --output build-time.vex.json
        
        echo "ğŸ“„ Generated build-time VEX:"
        jq '.vulnerabilities | length' build-time.vex.json || echo "0"

    # Consolidate all VEX documents using vexctl
    - name: Consolidate VEX documents
      run: |
        echo "ğŸ”„ Consolidating VEX documents using vexctl..."
        
        # Start with build-time VEX
        cp build-time.vex.json consolidated.vex.json
        
        # Merge existing VEX documents if any exist
        if [ -d "vex-sources" ] && [ "$(ls -A vex-sources/*.vex.json 2>/dev/null)" ]; then
          echo "ğŸ”— Merging with existing VEX documents..."
          for vex_file in vex-sources/*.vex.json; do
            if [ -f "$vex_file" ]; then
              echo "  ğŸ“„ Merging: $(basename $vex_file)"
              # Use vexctl to merge VEX documents
              vexctl merge \
                --product="pkg:oci/${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}" \
                consolidated.vex.json \
                "$vex_file" > temp.vex.json
              mv temp.vex.json consolidated.vex.json
            fi
          done
        else
          echo "ğŸ“„ No existing VEX documents to merge"
        fi
        
        echo "âœ… Consolidation complete. Final VEX document:"
        jq '.statements | length' consolidated.vex.json || echo "0 statements"

    # Apply VEX to filter scan results
    - name: Apply VEX filtering to scan results
      run: |
        echo "ğŸ”½ Applying VEX filtering to scan results..."
        
        # Convert Trivy JSON to SARIF for vexctl filtering
        trivy convert --format sarif --output unfiltered.sarif container-scan.json
        
        # Apply VEX filtering using vexctl
        vexctl filter unfiltered.sarif consolidated.vex.json > filtered.sarif
        
        # Show filtering results
        echo "ğŸ“Š VEX Filtering Results:"
        UNFILTERED_COUNT=$(jq '.runs[0].results | length' unfiltered.sarif 2>/dev/null || echo "0")
        FILTERED_COUNT=$(jq '.runs[0].results | length' filtered.sarif 2>/dev/null || echo "0")
        FILTERED_OUT=$((UNFILTERED_COUNT - FILTERED_COUNT))
        
        echo "  ğŸ” Original vulnerabilities: $UNFILTERED_COUNT"
        echo "  âœ… Remaining after VEX: $FILTERED_COUNT"
        echo "  ğŸš« Filtered out by VEX: $FILTERED_OUT"
        
        # Create summary for PR comments
        cat > vex-summary.md << EOF
        ## ğŸ›¡ï¸ VEX Filtering Summary
        
        | Metric | Count |
        |--------|-------|
        | Original vulnerabilities | $UNFILTERED_COUNT |
        | Remaining after VEX filtering | $FILTERED_COUNT |
        | **Filtered out by VEX** | **$FILTERED_OUT** |
        
        VEX documents successfully reduced the vulnerability report by **$FILTERED_OUT** entries.
        EOF

    # Upload filtered SARIF results to GitHub Security
    - name: Upload filtered SARIF results to GitHub Security
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'filtered.sarif'
        category: 'trivy-vex-filtered'

    # Upload VEX documents and results
    - name: Upload consolidated VEX document
      id: upload-vex
      uses: actions/upload-artifact@v4
      with:
        name: consolidated-vex-${{ github.sha }}
        path: |
          consolidated.vex.json
          vex-summary.md
          filtered.sarif
          unfiltered.sarif
          vex-attestation.jsonl
          vex-attestation-instructions.md
        retention-days: 90

    # Store VEX attestation as artifact and optionally attach to image
    - name: Attest VEX document to container image
      env:
        COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        # Use PAT if available for organization package writes, otherwise use GITHUB_TOKEN
        REGISTRY_TOKEN: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
      run: |
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
        echo "ğŸ” Attesting VEX document to container image: $IMAGE_REF"
        
        # Ensure we have a valid VEX document
        if [ ! -f "consolidated.vex.json" ]; then
          echo "âŒ consolidated.vex.json not found"
          exit 1
        fi
        
        # Validate VEX document structure
        echo "ğŸ” Validating VEX document..."
        jq empty consolidated.vex.json || {
          echo "âŒ Invalid VEX JSON document"
          exit 1
        }
        
        # Create a signed VEX attestation file
        echo "ğŸ” Creating signed VEX attestation..."
        cosign attest \
          --yes \
          --key env://COSIGN_PRIVATE_KEY \
          --type=openvex \
          --predicate=consolidated.vex.json \
          --output-file=vex-attestation.jsonl \
          "$IMAGE_REF" || {
          
          echo "âš ï¸  Direct image attestation failed (likely due to organization permissions)"
          echo "ğŸ“„ Creating standalone signed VEX attestation instead..."
          
          # Create a standalone attestation that can be verified later
          cosign attest \
            --yes \
            --key env://COSIGN_PRIVATE_KEY \
            --type=openvex \
            --predicate=consolidated.vex.json \
            --output-file=vex-attestation.jsonl \
            --no-upload \
            "$IMAGE_REF"
          
          echo "âœ… Standalone VEX attestation created successfully"
          echo "ğŸ“‹ To attach this attestation later with proper permissions:"
          echo "   cosign attach attestation --attestation vex-attestation.jsonl $IMAGE_REF"
          
          # Create instructions for manual attachment
          cat > vex-attestation-instructions.md << EOF
        # VEX Attestation Instructions
        
        The VEX attestation was created but could not be automatically attached due to organization permissions.
        
        ## To attach the attestation manually:
        
        1. Download the \`vex-attestation.jsonl\` file from the workflow artifacts
        2. Run the following command with appropriate permissions:
        
        \`\`\`bash
        cosign attach attestation --attestation vex-attestation.jsonl $IMAGE_REF
        \`\`\`
        
        ## To verify the standalone attestation:
        
        \`\`\`bash
        cosign verify-attestation --type=openvex --key cosign.pub $IMAGE_REF
        \`\`\`
        
        ## Image Reference:
        \`$IMAGE_REF\`
        EOF
          
          exit 0
        }
        
        echo "âœ… VEX attestation attached to image successfully"

  # Modified runtime VEX generation job
  runtime-vex-generation:
    needs: [build-container, vulnerability-analysis-with-vex]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      packages: read
    outputs:
      runtime-vex-generated: ${{ steps.runtime-vex.outputs.generated }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install vexctl
        uses: openvex/setup-vexctl@main
        with:
          vexctl-release: '0.3.0'

      - name: Create Kubernetes Kind Cluster
        id: kind
        uses: helm/kind-action@v1
        with:
          cluster_name: feelgood-cluster
          wait: 60s
          verbosity: 1

      - name: Verify cluster is ready
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Install Kubescape Operator with VEX Generation
        run: |
          echo "ğŸ”§ Installing Kubescape Operator with VEX generation enabled..."
          helm repo add kubescape https://kubescape.github.io/helm-charts/
          helm repo update
          
          # Install Kubescape with VEX generation enabled
          helm upgrade --install kubescape kubescape/kubescape-operator \
            -n kubescape \
            --create-namespace \
            --set clusterName=feelgood-cluster \
            --set capabilities.vexGeneration=enable \
            --set capabilities.vulnerabilityScan=enable \
            --set capabilities.relevancy=enable \
            --set capabilities.runtimeObservability=enable \
            --wait \
            --timeout=300s

      - name: Verify Kubescape deployment
        run: |
          echo "ğŸ” Verifying Kubescape pods are running..."
          kubectl get pods -n kubescape
          kubectl wait --for=condition=ready pod --all -n kubescape --timeout=300s

      - name: Deploy application with consolidated VEX
        run: |
          IMAGE_TAG="latest"
          FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
          
          echo "ğŸš€ Deploying image: $FULL_IMAGE"
          
          cat <<EOF > app-deployment.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ github.event.repository.name }}
            labels:
              app: ${{ github.event.repository.name }}
              vex-enabled: "true"
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ github.event.repository.name }}
            template:
              metadata:
                labels:
                  app: ${{ github.event.repository.name }}
                annotations:
                  vex.openvex.dev/available: "true"
              spec:
                containers:
                - name: ${{ github.event.repository.name }}
                  image: ${FULL_IMAGE}
                  imagePullPolicy: Always
                  ports:
                  - containerPort: 8000 
                  env:
                  - name: PORT
                    value: "8000"
                  - name: ENV
                    value: "production"
                  resources:
                    requests:
                      memory: "64Mi"
                      cpu: "50m"
                    limits:
                      memory: "256Mi"
                      cpu: "200m"
                  securityContext:
                    runAsNonRoot: true
                    runAsUser: 65534
                    allowPrivilegeEscalation: false
                    capabilities:
                      drop:
                      - ALL
                    readOnlyRootFilesystem: true
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ github.event.repository.name }}-service
          spec:
            type: NodePort
            ports:
            - port: 80
              targetPort: 8000
              nodePort: 30080
              protocol: TCP
            selector:
              app: ${{ github.event.repository.name }}
          EOF

          kubectl apply -f app-deployment.yaml
          kubectl wait --for=condition=available --timeout=300s deployment/${{ github.event.repository.name }}

      - name: Generate runtime load for VEX analysis
        run: |
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          echo "ğŸ”„ Generating runtime activity for better VEX analysis..."
          
          # Generate some load to trigger runtime analysis
          for i in {1..30}; do
            curl -s http://$NODE_IP:30080 > /dev/null 2>&1 || true
            sleep 2
          done

      - name: Wait for runtime VEX generation
        run: |
          echo "â³ Waiting for Kubescape to generate runtime VEX documents..."
          echo "ğŸ• Start time: $(date)"
          
          # Wait for VEX documents with timeout
          for i in {1..5}; do
            echo "â±ï¸  Minute $i/5 - $(date)"
            
            VEX_COUNT=$(kubectl get openvulnerabilityexchangecontainer -n kubescape 2>/dev/null | wc -l || echo "0")
            if [ "$VEX_COUNT" -gt 1 ]; then
              echo "ğŸ“„ Found $((VEX_COUNT-1)) runtime VEX document(s)"
              break
            else
              echo "ğŸ“„ No VEX documents generated yet..."
            fi
            
            sleep 60
          done

      - name: Extract and merge runtime VEX
        id: runtime-vex
        run: |
          echo "ğŸ“Š Extracting runtime VEX documents..."
          
          VEX_RESOURCES=$(kubectl get openvulnerabilityexchangecontainer -n kubescape --no-headers 2>/dev/null || echo "")
          
          if [ -z "$VEX_RESOURCES" ]; then
            echo "âš ï¸  No runtime VEX documents found"
            echo "generated=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Found runtime VEX documents"
            
            # Extract the first VEX document
            FIRST_VEX=$(kubectl get openvulnerabilityexchangecontainer -n kubescape --no-headers | head -1 | awk '{print $1}')
            kubectl get openvulnerabilityexchangecontainer "$FIRST_VEX" -n kubescape -o jsonpath='{.spec}' > runtime.vex.json
            
            # Download consolidated VEX from previous job
            # Note: In a real workflow, you'd download the artifact here
            # For now, we'll create a placeholder for the merge operation
            
            echo "ğŸ”„ Would merge runtime VEX with build-time VEX here"
            echo "ğŸ“„ Runtime VEX saved as runtime.vex.json"
            echo "generated=true" >> $GITHUB_OUTPUT
          fi

      - name: Upload runtime VEX
        if: steps.runtime-vex.outputs.generated == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: runtime-vex-${{ github.sha }}
          path: runtime.vex.json
          retention-days: 30

  slsa-provenance:
    needs: build-container
    if: github.event_name != 'pull_request'
    permissions:
      actions: read
      id-token: write
      packages: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v2.0.0
    with:
      image: ghcr.io/${{ github.repository }}
      digest: ${{ needs.build-container.outputs.image-digest }}
      registry-username: ${{ github.actor }}
    secrets:
      registry-password: ${{ secrets.GITHUB_TOKEN }}

  verify-attestations:
    needs: [build-container, slsa-provenance, vulnerability-analysis-with-vex]
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Install Cosign
      uses: sigstore/cosign-installer@v3
      
    - name: Install SLSA Verifier
      uses: slsa-framework/slsa-verifier/actions/installer@v2.5.1

    - name: Install vexctl
      uses: openvex/setup-vexctl@main
      with:
        vexctl-release: '0.3.0'
    
    - name: Verify container signature and SLSA provenance
      run: |
        # Verify signature
        cosign verify --key cosign.pub \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}
        
        # Verify SLSA provenance
        slsa-verifier verify-image \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }} \
          --source-uri github.com/${{ github.repository }}

    - name: Verify VEX attestation
      run: |
        echo "ğŸ” Verifying VEX attestation..."
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-container.outputs.image-digest }}"
        
        # Try to verify attached attestation first
        if cosign verify-attestation \
          --key cosign.pub \
          --type=openvex \
          "$IMAGE_REF" 2>/dev/null; then
          echo "âœ… VEX attestation verified on image"
        else
          echo "âš ï¸  No attached VEX attestation found on image"
          echo "ğŸ“„ This may be due to organization permissions"
          echo "ğŸ” VEX attestation was created as standalone artifact"
          echo "ğŸ“‹ Check workflow artifacts for vex-attestation.jsonl and instructions"
        fi

  # Summary job for PR comments
  vex-summary:
    needs: [vulnerability-analysis-with-vex, runtime-vex-generation]
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
    - name: Download VEX summary
      uses: actions/download-artifact@v4
      with:
        name: consolidated-vex-${{ github.sha }}

    - name: Comment VEX summary on PR
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          try {
            const summary = fs.readFileSync('vex-summary.md', 'utf8');
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
          } catch (error) {
            console.log('Could not read VEX summary:', error);
          }
