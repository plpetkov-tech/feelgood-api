name: 🔍 VEX Analysis

on:
  workflow_call:
    inputs:
      registry:
        required: true
        type: string
      image-name:
        required: true
        type: string
      image-digest:
        required: true
        type: string
      sbom-artifact:
        required: true
        type: string
      scan-artifact:
        required: true
        type: string
      vex-analysis-time:
        required: false
        type: string
        default: '2m'
    outputs:
      build-vex-artifact:
        description: "Build-time VEX artifact ID"
        value: ${{ jobs.build-time-vex-analysis.outputs.build-vex-artifact }}
      runtime-vex-artifact:
        description: "Runtime VEX artifact ID"
        value: ${{ jobs.runtime-vex-generation.outputs.runtime-vex-artifact }}

env:
  REGISTRY: ${{ inputs.registry }}
  IMAGE_NAME: ${{ inputs.image-name }}

jobs:
  # Build-time VEX generation (static analysis)
  build-time-vex-analysis:
    runs-on: ubuntu-latest
    outputs:
      build-vex-artifact: build-time-vex-${{ github.sha }}
    steps:
    - uses: actions/checkout@v4
    
    - name: 🔍 Initialize Build-time VEX Analysis
      run: |
        echo "## 🔍 Build-time VEX Analysis Phase" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "🎯 **Performing static vulnerability analysis and VEX generation**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
    
    - name: Log in to Container Registry
      uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
    
    - name: Install vexctl
      uses: openvex/setup-vexctl@e85ca48f3c8a376289f6476129d59cda82147e71
      with:
        vexctl-release: '0.3.0'
    
    - name: Download SBOM
      uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
      with:
        name: sbom-${{ github.sha }}
    
    - name: Download baseline scan
      uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
      with:
        name: baseline-scan-${{ github.sha }}
    
    # Verify image accessibility before scanning
    - name: 🔍 Verify image accessibility
      run: |
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ inputs.image-digest }}"
        echo "🔍 Verifying image accessibility: $IMAGE_REF"
        
        echo "### 🔍 Image Verification" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Try to inspect the image to ensure it's accessible
        if docker manifest inspect "$IMAGE_REF" > /dev/null 2>&1; then
          echo "✅ **Image manifest accessible**" >> $GITHUB_STEP_SUMMARY
          echo "🔍 **Image**: \`$IMAGE_REF\`" >> $GITHUB_STEP_SUMMARY
        elif docker pull "$IMAGE_REF" > /dev/null 2>&1; then
          echo "✅ **Image successfully pulled**" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ **Cannot access image - VEX attestation may fail**" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
    
    # Scan the built container image
    - name: 🛡️ Run Trivy vulnerability scanner on image
      uses: aquasecurity/trivy-action@76071ef0d7ec797419534a183b498b4d6366cf37
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ inputs.image-digest }}
        format: 'json'
        output: 'container-scan.json'
    
    - name: 📋 Run Trivy on SBOM
      uses: aquasecurity/trivy-action@76071ef0d7ec797419534a183b498b4d6366cf37
      with:
        scan-type: 'sbom'
        scan-ref: 'sbom.json'
        format: 'sarif'
        output: 'trivy-sbom-results.sarif'

    - name: 📊 Process Container Scan Results
      uses: ./.github/actions/security-reporter
      with:
        phase: "container-scan"
        scan-file: "container-scan.json"
        title: "🛡️ Container Security Scan Results"

    # Collect existing VEX documents from .vex/production and other sources
    - name: 📄 Collect existing VEX documents
      run: |
        echo "🔍 Collecting existing VEX documents from repository..."
        mkdir -p vex-sources
        
        # ONLY collect from .vex/production (reliable runtime VEX)
        if [ -d ".vex/production" ]; then
          echo "🎯 Found .vex/production directory - collecting ONLY reliable production VEX documents..."
          find .vex/production -name "*.vex.json" -exec cp {} vex-sources/ \;
        fi
        
        # Skip all other sources - they are causing pollution
        echo "⚠️ Skipping .vex/consolidated and other sources to avoid placeholder pollution"
        
        echo "### 📄 Existing VEX Documents" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # List found VEX documents
        if [ -d "vex-sources" ] && [ "$(ls -A vex-sources 2>/dev/null)" ]; then
          VEX_COUNT=$(ls -1 vex-sources/*.vex.json 2>/dev/null | wc -l || echo "0")
          echo "✅ **Found $VEX_COUNT existing VEX documents**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| File | Size | Source |" >> $GITHUB_STEP_SUMMARY
          echo "|------|------|--------|" >> $GITHUB_STEP_SUMMARY
          for vex_file in vex-sources/*.vex.json; do
            if [ -f "$vex_file" ]; then
              SIZE=$(stat -c%s "$vex_file" 2>/dev/null || echo "0")
              # Determine source based on filename patterns
              if [[ "$(basename $vex_file)" == *"runtime"* ]]; then
                SOURCE="🚀 Runtime"
              elif [[ "$(basename $vex_file)" == *"final"* ]] || [[ "$(basename $vex_file)" == *"consolidated"* ]]; then
                SOURCE="🔄 Consolidated"
              elif [[ "$(basename $vex_file)" == *"production"* ]] || [[ "$(basename $vex_file)" == *"prod"* ]]; then
                SOURCE="🏭 Production"
              elif [[ "$(basename $vex_file)" == *"build"* ]]; then
                SOURCE="🏗️ Build-time"
              else
                SOURCE="📋 Legacy"
              fi
              echo "| $(basename $vex_file) | ${SIZE} bytes | $SOURCE |" >> $GITHUB_STEP_SUMMARY
            fi
          done
        else
          echo "ℹ️ **No existing VEX documents found**" >> $GITHUB_STEP_SUMMARY
          echo "📁 **Checked locations**: .vex/production/, .vex/prod/, root directory" >> $GITHUB_STEP_SUMMARY
          touch vex-sources/.keep
        fi
        echo "" >> $GITHUB_STEP_SUMMARY

    # Generate build-time VEX from static scan results
    - name: 🔧 Generate build-time VEX document
      run: |
        echo "🔧 Generating build-time VEX document..."
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ inputs.image-digest }}"
        
        # Get commit author for VEX document
        COMMIT_AUTHOR=$(git log -1 --pretty=format:'%an <%ae>')
        
        python scripts/generate_vex.py \
          --trivy-results container-scan.json \
          --sbom sbom.json \
          --image-ref "$IMAGE_REF" \
          --author "$COMMIT_AUTHOR" \
          --output build-time.vex.json
        
        echo "### 🔧 Build-time VEX Generation" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ -f "build-time.vex.json" ]; then
          STATEMENT_COUNT=$(jq '.statements | length' build-time.vex.json 2>/dev/null || echo "0")
          NOT_AFFECTED=$(jq '.statements | map(select(.status == "not_affected")) | length' build-time.vex.json 2>/dev/null || echo "0")
          AFFECTED=$(jq '.statements | map(select(.status == "affected")) | length' build-time.vex.json 2>/dev/null || echo "0")
          UNDER_INVESTIGATION=$(jq '.statements | map(select(.status == "under_investigation")) | length' build-time.vex.json 2>/dev/null || echo "0")
          
          echo "| 📊 VEX Statements | Count | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------------|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| ✅ Not Affected | $NOT_AFFECTED | Safe |" >> $GITHUB_STEP_SUMMARY
          echo "| ⚠️ Affected | $AFFECTED | Requires Action |" >> $GITHUB_STEP_SUMMARY
          echo "| 🔍 Under Investigation | $UNDER_INVESTIGATION | Pending |" >> $GITHUB_STEP_SUMMARY
          echo "| 🎯 **Total Statements** | **$STATEMENT_COUNT** | |" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Build-time VEX document generated successfully**" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ **Failed to generate build-time VEX document**" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY

    # Create initial consolidated VEX (build-time + existing)
    - name: 🔄 Create initial consolidated VEX
      uses: ./.github/actions/vex-processor
      with:
        action: "consolidate-build-vex"
        build-vex: "build-time.vex.json"
        existing-vex-dir: "vex-sources"
        image-ref: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ inputs.image-digest }}"
        output: "initial-consolidated.vex.json"

    # Upload build-time VEX for runtime job
    - name: 📤 Upload build-time VEX artifacts
      id: upload-build-vex
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
      with:
        name: build-time-vex-${{ github.sha }}
        path: |
          build-time.vex.json
          initial-consolidated.vex.json
          container-scan.json
          trivy-sbom-results.sarif
        retention-days: 90

    - name: 🎯 Complete Build-time VEX Phase
      run: |
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## ✅ Build-time VEX Analysis Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "🎉 **Static vulnerability analysis and VEX generation finished**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Next Phase**: 🚀 Runtime VEX Generation" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

  # Runtime VEX generation with Kubescape
  runtime-vex-generation:
    needs: build-time-vex-analysis
    runs-on: ubuntu-latest
    outputs:
      runtime-vex-artifact: runtime-vex-${{ github.sha }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: 🚀 Initialize Runtime VEX Generation
        run: |
          echo "## 🚀 Runtime VEX Generation Phase" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🎯 **Performing dynamic runtime security analysis with Kubescape**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Install vexctl
        uses: openvex/setup-vexctl@e85ca48f3c8a376289f6476129d59cda82147e71
        with:
          vexctl-release: '0.3.0'

      # Set up runtime analysis environment
      - name: 🎲 Setup Runtime Analysis Environment
        id: runtime-setup
        uses: ./.github/actions/runtime-analyzer
        with:
          action: "setup-cluster"
          cluster-name: "feelgood-cluster"
          vex-analysis-time: ${{ inputs.vex-analysis-time }}
          use-external-cluster: ${{ secrets.KUBECONFIG != '' }}
        env:
          KUBECONFIG: ${{ secrets.KUBECONFIG }}

      - name: 🛡️ Deploy and analyze application
        uses: ./.github/actions/runtime-analyzer
        with:
          action: "deploy-and-analyze"
          image-ref: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ inputs.image-digest }}"
          app-name: "${{ github.event.repository.name }}"
          use-external-cluster: ${{ secrets.KUBECONFIG != '' }}
        env:
          KUBECONFIG: ${{ secrets.KUBECONFIG }}

      - name: 🎭 Start background runtime testing
        run: |
          echo "🎭 Starting continuous runtime testing during VEX analysis..."
          
          # Get node IP for testing
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          
          echo "### 🎭 Background Runtime Testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🔄 **Starting continuous testing to enhance VEX analysis**" >> $GITHUB_STEP_SUMMARY
          echo "🎯 **Target**: http://${NODE_IP}:30080" >> $GITHUB_STEP_SUMMARY
          echo "⏱️ **Duration**: Will run during VEX analysis period (${{ inputs.vex-analysis-time }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Convert analysis time to seconds for background testing
          ANALYSIS_TIME="${{ inputs.vex-analysis-time }}"
          if [[ "$ANALYSIS_TIME" =~ ^([0-9]+)m$ ]]; then
            BACKGROUND_DURATION=$((${BASH_REMATCH[1]} * 60))
          elif [[ "$ANALYSIS_TIME" =~ ^([0-9]+)s$ ]]; then
            BACKGROUND_DURATION=${BASH_REMATCH[1]}
          elif [[ "$ANALYSIS_TIME" =~ ^([0-9]+)h$ ]]; then
            BACKGROUND_DURATION=$((${BASH_REMATCH[1]} * 3600))
          else
            echo "⚠️ Invalid time format, defaulting to 120 seconds"
            BACKGROUND_DURATION=120
          fi
          
          echo "⚙️ **Background test duration**: ${BACKGROUND_DURATION} seconds" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Start background testing script that will run for the entire VEX analysis period
          if [ -f "scripts/test-during-runtime.sh" ]; then
            echo "🚀 Starting comprehensive background testing..."
            
            # Create a background testing script that repeats the test suite
            cat > background-runtime-test.sh << 'EOF'
          #!/bin/bash
          NODE_IP="$1"
          PORT="$2"
          DURATION="$3"
          
          echo "🎭 Background runtime testing started at $(date)"
          echo "🎯 Target: http://${NODE_IP}:${PORT}"
          echo "⏱️ Duration: ${DURATION} seconds"
          
          START_TIME=$(date +%s)
          CYCLE=1
          TOTAL_REQUESTS=0
          TOTAL_SUCCESS=0
          
          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            
            if [ $ELAPSED -ge $DURATION ]; then
              echo "⏰ Background testing duration reached, stopping..."
              break
            fi
            
            echo "🔄 Test cycle $CYCLE (elapsed: ${ELAPSED}s/${DURATION}s)"
            
            # Run a smaller subset of tests for continuous testing
            bash scripts/test-during-runtime.sh "$NODE_IP" "$PORT" > "cycle-${CYCLE}-output.log" 2>&1 &
            TEST_PID=$!
            
            # Wait for test to complete or timeout after 60 seconds
            timeout 60 wait $TEST_PID 2>/dev/null || {
              echo "⚠️ Test cycle $CYCLE timed out, killing..."
              kill $TEST_PID 2>/dev/null || true
            }
            
            # Extract stats if available
            if [ -f "cycle-${CYCLE}-output.log" ]; then
              CYCLE_REQUESTS=$(grep "Total Requests:" "cycle-${CYCLE}-output.log" | awk '{print $NF}' || echo "0")
              CYCLE_SUCCESS=$(grep "Successful:" "cycle-${CYCLE}-output.log" | awk '{print $NF}' || echo "0")
              TOTAL_REQUESTS=$((TOTAL_REQUESTS + CYCLE_REQUESTS))
              TOTAL_SUCCESS=$((TOTAL_SUCCESS + CYCLE_SUCCESS))
            fi
            
            CYCLE=$((CYCLE + 1))
            
            # Short pause between cycles
            sleep 10
          done
          
          echo "🎊 Background testing completed!"
          echo "📊 Total cycles: $((CYCLE - 1))"
          echo "📊 Total requests: $TOTAL_REQUESTS"
          echo "📊 Total successful: $TOTAL_SUCCESS"
          echo "📊 Overall success rate: $((TOTAL_REQUESTS > 0 ? TOTAL_SUCCESS * 100 / TOTAL_REQUESTS : 0))%"
          
          # Save final stats
          cat > background-test-stats.json << STATS_EOF
          {
            "cycles": $((CYCLE - 1)),
            "total_requests": $TOTAL_REQUESTS,
            "total_success": $TOTAL_SUCCESS,
            "success_rate": $((TOTAL_REQUESTS > 0 ? TOTAL_SUCCESS * 100 / TOTAL_REQUESTS : 0)),
            "duration_seconds": $DURATION,
            "end_time": "$(date)"
          }
          STATS_EOF
          EOF
            
            chmod +x background-runtime-test.sh
            
            # Start background testing
            nohup bash background-runtime-test.sh "$NODE_IP" "30080" "$BACKGROUND_DURATION" > background-test.log 2>&1 &
            BACKGROUND_PID=$!
            
            echo "✅ **Background testing started** (PID: $BACKGROUND_PID)" >> $GITHUB_STEP_SUMMARY
            echo "🔄 **Will run continuously during VEX analysis period**" >> $GITHUB_STEP_SUMMARY
            
            # Save PID for later cleanup
            echo "$BACKGROUND_PID" > background-test.pid
          else
            echo "⚠️ **Runtime test script not found, skipping background testing**" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ⏳ Wait for runtime VEX generation
        run: |
          echo "⏳ Waiting for Kubescape to generate runtime VEX documents..."
          echo "🕐 Start time: $(date)"
          echo "⚙️ VEX analysis duration: ${{ inputs.vex-analysis-time }}"
          
          echo "### ⏳ Waiting for Runtime VEX Generation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🔍 **Monitoring Kubescape for VEX document generation...**" >> $GITHUB_STEP_SUMMARY
          echo "⚙️ **Configured analysis time: ${{ inputs.vex-analysis-time }}**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Convert analysis time to seconds for timeout calculation
          ANALYSIS_TIME="${{ inputs.vex-analysis-time }}"
          if [[ "$ANALYSIS_TIME" =~ ^([0-9]+)m$ ]]; then
            ANALYSIS_SECONDS=$((${BASH_REMATCH[1]} * 60))
          elif [[ "$ANALYSIS_TIME" =~ ^([0-9]+)s$ ]]; then
            ANALYSIS_SECONDS=${BASH_REMATCH[1]}
          elif [[ "$ANALYSIS_TIME" =~ ^([0-9]+)h$ ]]; then
            ANALYSIS_SECONDS=$((${BASH_REMATCH[1]} * 3600))
          else
            echo "⚠️ Invalid time format, defaulting to 120 seconds"
            ANALYSIS_SECONDS=120
          fi
          
          # Add buffer time (50% more than analysis time)
          WAIT_SECONDS=$((ANALYSIS_SECONDS + ANALYSIS_SECONDS / 2))
          WAIT_MINUTES=$((WAIT_SECONDS / 60))
          
          echo "📊 **Wait strategy**: ${WAIT_MINUTES} minutes (analysis: ${ANALYSIS_SECONDS}s + buffer)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Wait for VEX documents with dynamic timeout
          for i in $(seq 1 $WAIT_MINUTES); do
            echo "⏱️  Minute $i/$WAIT_MINUTES - $(date)"
            
            # Try with full CRD name first, then fallback to short name
            VEX_COUNT=$(kubectl get openvulnerabilityexchangecontainers.spdx.softwarecomposition.kubescape.io -n kubescape 2>/dev/null | wc -l || echo "0")
            if [ "$VEX_COUNT" -eq 0 ]; then
              VEX_COUNT=$(kubectl get openvulnerabilityexchangecontainer -n kubescape 2>/dev/null | wc -l || echo "0")
            fi
            
            if [ "$VEX_COUNT" -gt 1 ]; then
              echo "📄 Found $((VEX_COUNT-1)) runtime VEX document(s)"
              echo "✅ **Runtime VEX documents generated in $i minutes**" >> $GITHUB_STEP_SUMMARY
              break
            else
              echo "📄 No VEX documents generated yet..."
              echo "⏱️ **Minute $i/$WAIT_MINUTES**: No VEX documents yet..." >> $GITHUB_STEP_SUMMARY
            fi
            
            sleep 60
          done
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: 📊 Collect background test results
        run: |
          echo "📊 Collecting background runtime test results..."
          
          echo "### 📊 Background Testing Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check if background testing completed and collect results
          if [ -f "background-test-stats.json" ]; then
            CYCLES=$(jq -r '.cycles // 0' background-test-stats.json)
            TOTAL_REQUESTS=$(jq -r '.total_requests // 0' background-test-stats.json)
            TOTAL_SUCCESS=$(jq -r '.total_success // 0' background-test-stats.json)
            SUCCESS_RATE=$(jq -r '.success_rate // 0' background-test-stats.json)
            
            echo "✅ **Background testing completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| 🎭 Background Test Results | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------------------------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| 🔄 Test Cycles | $CYCLES |" >> $GITHUB_STEP_SUMMARY
            echo "| 📊 Total Requests | $TOTAL_REQUESTS |" >> $GITHUB_STEP_SUMMARY
            echo "| ✅ Successful Requests | $TOTAL_SUCCESS |" >> $GITHUB_STEP_SUMMARY
            echo "| 📈 Success Rate | ${SUCCESS_RATE}% |" >> $GITHUB_STEP_SUMMARY
            echo "| 🎯 Test Coverage | Health, API, Security, Fuzzing, Load, Edge Cases |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
          elif [ -f "background-test.pid" ]; then
            BACKGROUND_PID=$(cat background-test.pid)
            if ps -p "$BACKGROUND_PID" > /dev/null 2>&1; then
              echo "🔄 **Background testing still running, stopping gracefully...**" >> $GITHUB_STEP_SUMMARY
              kill -TERM "$BACKGROUND_PID" 2>/dev/null || true
              sleep 5
              kill -KILL "$BACKGROUND_PID" 2>/dev/null || true
            fi
            
            # Try to get partial results
            if [ -f "background-test.log" ]; then
              PARTIAL_CYCLES=$(grep -c "Test cycle" background-test.log || echo "0")
              echo "⚠️ **Background testing stopped early**" >> $GITHUB_STEP_SUMMARY
              echo "📊 **Partial results**: $PARTIAL_CYCLES test cycles completed" >> $GITHUB_STEP_SUMMARY
            else
              echo "⚠️ **Background testing did not complete**" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "ℹ️ **No background testing was performed**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🎯 **Background testing enhanced runtime behavior analysis for VEX generation**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: 📊 Extract runtime VEX documents
        run: |
          echo "📊 Extracting runtime VEX documents..."
          
          echo "### 📊 Runtime VEX Extraction" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Get all VEX resources with the full CRD name
          VEX_RESOURCES=$(kubectl get openvulnerabilityexchangecontainers.spdx.softwarecomposition.kubescape.io -n kubescape --no-headers 2>/dev/null || echo "")
          
          if [ -z "$VEX_RESOURCES" ]; then
            echo "⚠️ **No runtime VEX documents found from Kubescape**" >> $GITHUB_STEP_SUMMARY
            echo "📋 **Checking for alternative VEX resource names...**" >> $GITHUB_STEP_SUMMARY
            
            # Try shorter form as fallback
            VEX_RESOURCES=$(kubectl get openvulnerabilityexchangecontainer -n kubescape --no-headers 2>/dev/null || echo "")
            
            if [ -z "$VEX_RESOURCES" ]; then
              echo "📋 **No VEX documents found, creating placeholder**" >> $GITHUB_STEP_SUMMARY
              # Create empty placeholder to avoid workflow failures
              echo '{"@context": "https://openvex.dev/ns/v0.2.0", "statements": []}' > runtime.vex.json
              echo "📄 **Created minimal placeholder for workflow continuity**" >> $GITHUB_STEP_SUMMARY
            else
              echo "✅ **Found VEX documents using fallback resource name**" >> $GITHUB_STEP_SUMMARY
              VEX_COUNT=$(echo "$VEX_RESOURCES" | wc -l)
              echo "📊 **Total VEX documents**: $VEX_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # List all found VEX documents for debugging
              echo "| 📋 Found VEX Documents | Created At |" >> $GITHUB_STEP_SUMMARY
              echo "|------------------------|------------|" >> $GITHUB_STEP_SUMMARY
              echo "$VEX_RESOURCES" | while read -r line; do
                VEX_NAME=$(echo "$line" | awk '{print $1}')
                CREATED_AT=$(echo "$line" | awk '{print $2}')
                echo "| $VEX_NAME | $CREATED_AT |" >> $GITHUB_STEP_SUMMARY
              done
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Extract the first VEX document using fallback name
              FIRST_VEX=$(echo "$VEX_RESOURCES" | head -1 | awk '{print $1}')
              kubectl get openvulnerabilityexchangecontainer "$FIRST_VEX" -n kubescape -o jsonpath='{.spec}' > runtime.vex.json
              echo "📄 **Runtime VEX extracted**: $FIRST_VEX" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "✅ **Found runtime VEX documents**" >> $GITHUB_STEP_SUMMARY
            VEX_COUNT=$(echo "$VEX_RESOURCES" | wc -l)
            echo "📊 **Total VEX documents**: $VEX_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # List all found VEX documents for debugging
            echo "| 📋 Found VEX Documents | Created At |" >> $GITHUB_STEP_SUMMARY
            echo "|------------------------|------------|" >> $GITHUB_STEP_SUMMARY
            echo "$VEX_RESOURCES" | while read -r line; do
              VEX_NAME=$(echo "$line" | awk '{print $1}')
              CREATED_AT=$(echo "$line" | awk '{print $2}')
              echo "| $VEX_NAME | $CREATED_AT |" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Look for our specific application image in the VEX documents
            APP_IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
            # Convert image name to expected VEX resource naming pattern (replace special chars with -)
            VEX_PATTERN=$(echo "$APP_IMAGE_NAME" | sed 's|[/.:]|-|g' | tr '[:upper:]' '[:lower:]')
            
            echo "🔍 **Looking for VEX document matching our image pattern**: $VEX_PATTERN" >> $GITHUB_STEP_SUMMARY
            
            # Try to find a VEX document that matches our image
            MATCHING_VEX=$(echo "$VEX_RESOURCES" | grep -i "$VEX_PATTERN" | head -1 | awk '{print $1}' || echo "")
            
            if [ -n "$MATCHING_VEX" ]; then
              echo "🎯 **Found matching VEX document**: $MATCHING_VEX" >> $GITHUB_STEP_SUMMARY
              kubectl get openvulnerabilityexchangecontainers.spdx.softwarecomposition.kubescape.io "$MATCHING_VEX" -n kubescape -o jsonpath='{.spec}' > runtime.vex.json
              echo "📄 **Extracted VEX for our application image**" >> $GITHUB_STEP_SUMMARY
            else
              echo "⚠️ **No VEX document found for our specific image, using first available**" >> $GITHUB_STEP_SUMMARY
              # Extract the first VEX document
              FIRST_VEX=$(echo "$VEX_RESOURCES" | head -1 | awk '{print $1}')
              kubectl get openvulnerabilityexchangecontainers.spdx.softwarecomposition.kubescape.io "$FIRST_VEX" -n kubescape -o jsonpath='{.spec}' > runtime.vex.json
              echo "📄 **Extracted first available VEX**: $FIRST_VEX" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          # Validate runtime VEX
          if jq empty runtime.vex.json 2>/dev/null; then
            STATEMENT_COUNT=$(jq '.statements | length' runtime.vex.json 2>/dev/null || echo "0")
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| 📋 Runtime VEX Details | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------------------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| ✅ Valid JSON | Yes |" >> $GITHUB_STEP_SUMMARY
            echo "| 📊 Statements | $STATEMENT_COUNT |" >> $GITHUB_STEP_SUMMARY
            echo "| ⚡ Runtime Analysis | Complete |" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Invalid runtime VEX JSON, creating placeholder**" >> $GITHUB_STEP_SUMMARY
            echo '{"@context": "https://openvex.dev/ns/v0.2.0", "statements": []}' > runtime.vex.json
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Upload runtime VEX
        id: upload-runtime-vex
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: runtime-vex-${{ github.sha }}
          path: runtime.vex.json
          retention-days: 30

      - name: 🧹 Cleanup Runtime Environment
        if: always()
        uses: ./.github/actions/runtime-analyzer
        with:
          action: "cleanup"
          cluster-name: "feelgood-cluster"
          use-external-cluster: ${{ secrets.KUBECONFIG != '' }}
        env:
          KUBECONFIG: ${{ secrets.KUBECONFIG }}

      - name: 🎯 Complete Runtime VEX Phase
        run: |
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ✅ Runtime VEX Generation Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🎉 **Dynamic runtime security analysis finished**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Phase**: 🔒 Final VEX Consolidation & Attestation" >> $GITHUB_STEP_SUMMARY
