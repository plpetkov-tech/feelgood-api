name: 'Runtime Analyzer'
description: 'Setup Kubescape runtime analysis environment and perform dynamic security analysis'
inputs:
  action:
    description: 'Action to perform (setup-cluster, deploy-and-analyze, cleanup)'
    required: true
  cluster-name:
    description: 'Kubernetes cluster name'
    required: false
    default: 'security-analysis-cluster'
  image-ref:
    description: 'Container image reference to analyze'
    required: false
  app-name:
    description: 'Application name for deployment'
    required: false
  timeout:
    description: 'Timeout for operations in seconds'
    required: false
    default: '600'
  vex-analysis-time:
    description: 'VEX analysis duration (e.g., "2m", "5m", "10m")'
    required: false
    default: '2m'
  use-external-cluster:
    description: 'Whether to use external cluster (true/false)'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Setup KUBECONFIG if external cluster
      if: ${{ inputs.use-external-cluster == 'true' }}
      shell: bash
      run: |
        mkdir -p ~/.kube
        echo "$KUBECONFIG" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config
        echo "‚úÖ KUBECONFIG written to ~/.kube/config"
      env:
        KUBECONFIG: ${{ env.KUBECONFIG }}
    - name: Runtime Analysis Operations
      shell: bash
      run: |
        case "${{ inputs.action }}" in
          "setup-cluster")
            echo "üé≤ Setting up Kubernetes cluster for runtime analysis..."
            
            # Check if we should use external cluster
            if [ "${{ inputs.use-external-cluster }}" = "true" ]; then
              echo "üîó Using existing Kubernetes cluster from KUBECONFIG secret..."
              
              # Verify cluster connectivity (kubeconfig already set up in previous step)
              if kubectl cluster-info > /dev/null 2>&1; then
                NODE_COUNT=$(kubectl get nodes --no-headers | wc -l)
                K8S_VERSION=$(kubectl version --client=false -o json | jq -r '.serverVersion.gitVersion')
                CLUSTER_NAME=$(kubectl config current-context)
                
                echo "### üîó Existing Kubernetes Cluster" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "| üìã Cluster Information | Value |" >> $GITHUB_STEP_SUMMARY
                echo "|------------------------|-------|" >> $GITHUB_STEP_SUMMARY
                echo "| üîó Cluster Context | $CLUSTER_NAME |" >> $GITHUB_STEP_SUMMARY
                echo "| üñ•Ô∏è Node Count | $NODE_COUNT |" >> $GITHUB_STEP_SUMMARY
                echo "| ‚öôÔ∏è Kubernetes Version | $K8S_VERSION |" >> $GITHUB_STEP_SUMMARY
                echo "| üîß Runtime | External Cluster |" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "‚úÖ **Using existing Kubernetes cluster**" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
              else
                echo "‚ùå **Failed to connect to existing cluster, falling back to Kind**" >> $GITHUB_STEP_SUMMARY
                USE_KIND=true
              fi
            else
              USE_KIND=true
            fi
            
            # Fallback to Kind cluster if no external cluster or connection failed
            if [ "${USE_KIND:-false}" = "true" ]; then
              echo "üé≤ Creating new Kind cluster for runtime analysis..."
              
              # Create Kind cluster
              cat > kind-config.yaml << EOF
        kind: Cluster
        apiVersion: kind.x-k8s.io/v1alpha4
        name: ${{ inputs.cluster-name }}
        nodes:
        - role: control-plane
          kubeadmConfigPatches:
          - |
            kind: InitConfiguration
            nodeRegistration:
              kubeletExtraArgs:
                node-labels: "ingress-ready=true"
          extraPortMappings:
          - containerPort: 30080
            hostPort: 30080
            protocol: TCP
        EOF
              
              # Install Kind if not present
              if ! command -v kind &> /dev/null; then
                curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
                chmod +x ./kind
                sudo mv ./kind /usr/local/bin/kind
              fi
              
              # Create cluster
              kind create cluster --config=kind-config.yaml --wait=60s
              
              # Verify cluster
              kubectl cluster-info
              NODE_COUNT=$(kubectl get nodes --no-headers | wc -l)
              K8S_VERSION=$(kubectl version --client=false -o json | jq -r '.serverVersion.gitVersion')
              
              echo "### üé≤ Kind Kubernetes Cluster" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "| üìã Cluster Information | Value |" >> $GITHUB_STEP_SUMMARY
              echo "|------------------------|-------|" >> $GITHUB_STEP_SUMMARY
              echo "| üé≤ Cluster Name | ${{ inputs.cluster-name }} |" >> $GITHUB_STEP_SUMMARY
              echo "| üñ•Ô∏è Node Count | $NODE_COUNT |" >> $GITHUB_STEP_SUMMARY
              echo "| ‚öôÔ∏è Kubernetes Version | $K8S_VERSION |" >> $GITHUB_STEP_SUMMARY
              echo "| üîß Runtime | Kind (Docker) |" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "‚úÖ **Kind cluster ready for deployment**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            
            # Install Kubescape Operator
            echo "üõ°Ô∏è Installing Kubescape Operator with VEX generation..."
            helm repo add kubescape https://kubescape.github.io/helm-charts/
            helm repo update
            
            echo "### üõ°Ô∏è Kubescape Operator Installation" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Install Kubescape with VEX generation enabled
            echo "üîß Configuring VEX analysis duration: ${{ inputs.vex-analysis-time }}"
            if helm upgrade --install kubescape kubescape/kubescape-operator \
              -n kubescape \
              --create-namespace \
              --set clusterName=${{ inputs.cluster-name }} \
              --set capabilities.vexGeneration=enable \
              --set capabilities.vulnerabilityScan=enable \
              --set capabilities.relevancy=enable \
              --set capabilities.runtimeObservability=enable \
              --set nodeAgent.config.applicationActivityTime=${{ inputs.vex-analysis-time }} \
              --wait \
              --timeout=${{ inputs.timeout }}s; then
              
              echo "‚úÖ **Kubescape Operator installed successfully**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "| üîß Capability | Status | Configuration |" >> $GITHUB_STEP_SUMMARY
              echo "|---------------|--------|---------------|" >> $GITHUB_STEP_SUMMARY
              echo "| üìã VEX Generation | ‚úÖ Enabled | Activity time: ${{ inputs.vex-analysis-time }} |" >> $GITHUB_STEP_SUMMARY
              echo "| üõ°Ô∏è Vulnerability Scan | ‚úÖ Enabled | - |" >> $GITHUB_STEP_SUMMARY
              echo "| üéØ Relevancy Analysis | ‚úÖ Enabled | - |" >> $GITHUB_STEP_SUMMARY
              echo "| üîç Runtime Observability | ‚úÖ Enabled | - |" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ùå **Kubescape installation failed**" >> $GITHUB_STEP_SUMMARY
              exit 1
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Verify Kubescape core components with progressive timeout
            echo "üîç Verifying Kubescape deployment..."
            
            # Define critical components that must be ready
            CRITICAL_COMPONENTS=("kubescape" "kubevuln")
            
            echo "### üîç Kubescape Pod Status" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Wait for critical components first
            CRITICAL_SUCCESS=true
            for component in "${CRITICAL_COMPONENTS[@]}"; do
              echo "‚è≥ Waiting for $component pods..."
              if kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=$component -n kubescape --timeout=180s; then
                echo "‚úÖ **$component pods ready**" >> $GITHUB_STEP_SUMMARY
              else
                echo "‚ùå **$component pods failed to start**" >> $GITHUB_STEP_SUMMARY
                CRITICAL_SUCCESS=false
              fi
            done
            
            # Check all pods status (informational)
            POD_COUNT=$(kubectl get pods -n kubescape --no-headers | wc -l)
            READY_COUNT=$(kubectl get pods -n kubescape --no-headers | grep -c "Running" || echo "0")
            PENDING_COUNT=$(kubectl get pods -n kubescape --no-headers | grep -c "Pending\|ContainerCreating" || echo "0")
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| üìä Pod Metrics | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|----------------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| üöÄ Total Pods | $POD_COUNT |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚úÖ Running Pods | $READY_COUNT |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚è≥ Pending Pods | $PENDING_COUNT |" >> $GITHUB_STEP_SUMMARY
            echo "| üéØ Success Rate | $((POD_COUNT > 0 ? READY_COUNT * 100 / POD_COUNT : 0))% |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Show detailed pod status for debugging
            echo "<details><summary>üìã Detailed Pod Status</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            kubectl get pods -n kubescape -o wide >> $GITHUB_STEP_SUMMARY 2>&1 || echo "Failed to get pod status" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [ "$CRITICAL_SUCCESS" = "true" ]; then
              echo "‚úÖ **Critical Kubescape components are running**" >> $GITHUB_STEP_SUMMARY
              if [ "$PENDING_COUNT" -gt 0 ]; then
                echo "‚ö†Ô∏è **Some non-critical pods still starting (this is normal)**" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "‚ùå **Critical Kubescape components failed to start**" >> $GITHUB_STEP_SUMMARY
              echo "üîß **Attempting to continue with available components...**" >> $GITHUB_STEP_SUMMARY
              # Don't exit - continue with what we have
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            ;;
            
          "deploy-and-analyze")
            echo "üöÄ Deploying application for runtime analysis..."
            
            if [ -z "${{ inputs.image-ref }}" ] || [ -z "${{ inputs.app-name }}" ]; then
              echo "‚ùå image-ref and app-name are required for deploy-and-analyze"
              exit 1
            fi
            
            echo "### üöÄ Application Deployment" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéØ **Deploying image for runtime analysis: ${{ inputs.image-ref }}**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Create deployment manifest
            cat > app-deployment.yaml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ${{ inputs.app-name }}
          labels:
            app: ${{ inputs.app-name }}
            vex-enabled: "true"
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: ${{ inputs.app-name }}
          template:
            metadata:
              labels:
                app: ${{ inputs.app-name }}
              annotations:
                vex.openvex.dev/available: "true"
            spec:
              containers:
              - name: ${{ inputs.app-name }}
                image: ${{ inputs.image-ref }}
                imagePullPolicy: Always
                ports:
                - containerPort: 8000 
                env:
                - name: PORT
                  value: "8000"
                - name: ENV
                  value: "production"
                resources:
                  requests:
                    memory: "64Mi"
                    cpu: "50m"
                  limits:
                    memory: "256Mi"
                    cpu: "200m"
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 65532 
                  allowPrivilegeEscalation: false
                  capabilities:
                    drop:
                    - ALL
                  readOnlyRootFilesystem: true
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: ${{ inputs.app-name }}-service
        spec:
          type: NodePort
          ports:
          - port: 80
            targetPort: 8000
            nodePort: 30080
            protocol: TCP
          selector:
            app: ${{ inputs.app-name }}
        EOF

            # Deploy application
            kubectl apply -f app-deployment.yaml
            
            # Wait for deployment with progressive checks
            echo "‚è≥ Waiting for deployment to be available..."
            
            # First wait for deployment to exist
            for i in {1..30}; do
              if kubectl get deployment ${{ inputs.app-name }} >/dev/null 2>&1; then
                break
              fi
              echo "‚è≥ Waiting for deployment to be created... ($i/30)"
              sleep 2
            done
            
            # Now wait for availability with shorter timeout and retries
            DEPLOYMENT_SUCCESS=false
            for attempt in {1..3}; do
              echo "üéØ Deployment attempt $attempt/3..."
              if kubectl wait --for=condition=available --timeout=120s deployment/${{ inputs.app-name }}; then
                DEPLOYMENT_SUCCESS=true
                break
              else
                echo "‚ö†Ô∏è Attempt $attempt failed, checking pod status..."
                kubectl get pods -l app=${{ inputs.app-name }} -o wide || true
                if [ $attempt -lt 3 ]; then
                  echo "üîÑ Retrying in 30 seconds..."
                  sleep 30
                fi
              fi
            done
            
            if [ "$DEPLOYMENT_SUCCESS" = "true" ]; then
              REPLICAS=$(kubectl get deployment ${{ inputs.app-name }} -o jsonpath='{.status.replicas}')
              READY_REPLICAS=$(kubectl get deployment ${{ inputs.app-name }} -o jsonpath='{.status.readyReplicas}')
              
              echo "| üìã Deployment Info | Value |" >> $GITHUB_STEP_SUMMARY
              echo "|-------------------|-------|" >> $GITHUB_STEP_SUMMARY
              echo "| üöÄ Application | ${{ inputs.app-name }} |" >> $GITHUB_STEP_SUMMARY
              echo "| üñºÔ∏è Image | \`${{ inputs.image-ref }}\` |" >> $GITHUB_STEP_SUMMARY
              echo "| üìä Replicas | $REPLICAS |" >> $GITHUB_STEP_SUMMARY
              echo "| ‚úÖ Ready Replicas | $READY_REPLICAS |" >> $GITHUB_STEP_SUMMARY
              echo "| üîí Security Context | Non-root, read-only filesystem |" >> $GITHUB_STEP_SUMMARY
              echo "| üõ°Ô∏è VEX Enabled | ‚úÖ Yes |" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "‚úÖ **Application deployed successfully with security hardening**" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ùå **Application deployment failed after 3 attempts**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "<details><summary>üîç Deployment Troubleshooting</summary>" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "=== Deployment Status ===" >> $GITHUB_STEP_SUMMARY
              kubectl describe deployment ${{ inputs.app-name }} >> $GITHUB_STEP_SUMMARY 2>&1 || echo "Failed to get deployment status" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "=== Pod Status ===" >> $GITHUB_STEP_SUMMARY
              kubectl get pods -l app=${{ inputs.app-name }} -o wide >> $GITHUB_STEP_SUMMARY 2>&1 || echo "No pods found" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "=== Pod Logs ===" >> $GITHUB_STEP_SUMMARY
              kubectl logs -l app=${{ inputs.app-name }} --tail=50 >> $GITHUB_STEP_SUMMARY 2>&1 || echo "No logs available" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "</details>" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "üîß **Continuing with partial deployment for VEX generation...**" >> $GITHUB_STEP_SUMMARY
              # Don't exit - try to continue with partial deployment
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Generate runtime load
            echo "üîÑ Starting comprehensive runtime testing for VEX analysis..."
            NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
            
            echo "### üîÑ Runtime Load Generation" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéØ **Running comprehensive runtime tests to trigger security analysis**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            SUCCESS_COUNT=0
            TOTAL_REQUESTS=0
            
            # Test service connectivity first
            echo "üîç Testing service connectivity..."
            SERVICE_READY=false
            for test_attempt in {1..10}; do
              if curl -s --max-time 10 "http://$NODE_IP:30080/health" > /dev/null 2>&1 || \
                 curl -s --max-time 10 "http://$NODE_IP:30080" > /dev/null 2>&1; then
                SERVICE_READY=true
                echo "‚úÖ Service is responding"
                break
              else
                echo "‚è≥ Waiting for service to be ready... ($test_attempt/10)"
                sleep 5
              fi
            done
            
            if [ "$SERVICE_READY" = "true" ]; then
              echo "üöÄ **Service ready - starting comprehensive testing**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Run the comprehensive runtime testing script
              echo "üé≠ Running runtime test suite..."
              
              if [ -f "scripts/test-during-runtime.sh" ]; then
                echo "‚úÖ **Runtime test script found - executing comprehensive test suite**" >> $GITHUB_STEP_SUMMARY
                
                # Run the script and capture output
                if timeout 300 bash scripts/test-during-runtime.sh "$NODE_IP" "30080" > runtime-test-output.log 2>&1; then
                  TOTAL_REQUESTS=$(grep "Total Requests:" runtime-test-output.log | awk '{print $NF}' || echo "0")
                  SUCCESS_COUNT=$(grep "Successful:" runtime-test-output.log | awk '{print $NF}' || echo "0")
                  SUCCESS_RATE=$(grep "Success Rate:" runtime-test-output.log | awk '{print $NF}' | tr -d '%' || echo "0")
                  
                  echo "‚úÖ **Comprehensive runtime testing completed successfully**" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "| üéØ Test Results | Value |" >> $GITHUB_STEP_SUMMARY
                  echo "|----------------|-------|" >> $GITHUB_STEP_SUMMARY
                  echo "| üìä Total Requests | $TOTAL_REQUESTS |" >> $GITHUB_STEP_SUMMARY
                  echo "| ‚úÖ Successful Requests | $SUCCESS_COUNT |" >> $GITHUB_STEP_SUMMARY
                  echo "| üìà Success Rate | ${SUCCESS_RATE}% |" >> $GITHUB_STEP_SUMMARY
                  echo "| üé≠ Test Categories | Health, API, Security, Fuzzing, Load, Edge Cases |" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  
                  # Show test phases completed
                  echo "<details><summary>üîç Test Execution Details</summary>" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  tail -20 runtime-test-output.log >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "Test output not available" >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  echo "</details>" >> $GITHUB_STEP_SUMMARY
                  
                else
                  echo "‚ö†Ô∏è **Runtime test script timed out or failed, falling back to basic load generation**" >> $GITHUB_STEP_SUMMARY
                  
                  # Fallback to basic load generation
                  SUCCESS_COUNT=0
                  TOTAL_REQUESTS=30
                  for i in $(seq 1 $TOTAL_REQUESTS); do
                    if curl -s --max-time 5 "http://$NODE_IP:30080" > /dev/null 2>&1; then
                      SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                    fi
                    sleep 1
                  done
                fi
              else
                echo "‚ö†Ô∏è **Runtime test script not found, using basic load generation**" >> $GITHUB_STEP_SUMMARY
                
                # Fallback to basic load generation
                SUCCESS_COUNT=0
                TOTAL_REQUESTS=30
                for i in $(seq 1 $TOTAL_REQUESTS); do
                  if curl -s --max-time 5 "http://$NODE_IP:30080" > /dev/null 2>&1; then
                    SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                  fi
                  if [ $((i % 10)) -eq 0 ]; then
                    PROGRESS=$((i * 100 / TOTAL_REQUESTS))
                    echo "üìä Progress: $PROGRESS% ($i/$TOTAL_REQUESTS requests)" >> $GITHUB_STEP_SUMMARY
                  fi
                  sleep 1
                done
                
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "| üìä Basic Load Results | Value |" >> $GITHUB_STEP_SUMMARY
                echo "|----------------------|-------|" >> $GITHUB_STEP_SUMMARY
                echo "| üéØ Total Requests | $TOTAL_REQUESTS |" >> $GITHUB_STEP_SUMMARY
                echo "| ‚úÖ Successful Requests | $SUCCESS_COUNT |" >> $GITHUB_STEP_SUMMARY
                echo "| üìà Success Rate | $((TOTAL_REQUESTS > 0 ? SUCCESS_COUNT * 100 / TOTAL_REQUESTS : 0))% |" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "‚ö†Ô∏è **Service not responding, generating minimal load...**" >> $GITHUB_STEP_SUMMARY
              # Still attempt some requests to trigger analysis
              SUCCESS_COUNT=0
              TOTAL_REQUESTS=5
              for i in $(seq 1 $TOTAL_REQUESTS); do
                curl -s --max-time 10 "http://$NODE_IP:30080" > /dev/null 2>&1 && SUCCESS_COUNT=$((SUCCESS_COUNT + 1)) || true
                sleep 3
              done
              
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "| üìä Minimal Load Results | Value |" >> $GITHUB_STEP_SUMMARY
              echo "|------------------------|-------|" >> $GITHUB_STEP_SUMMARY
              echo "| üéØ Total Requests | $TOTAL_REQUESTS |" >> $GITHUB_STEP_SUMMARY
              echo "| ‚úÖ Successful Requests | $SUCCESS_COUNT |" >> $GITHUB_STEP_SUMMARY
              echo "| üìà Success Rate | $((SUCCESS_COUNT * 100 / TOTAL_REQUESTS))% |" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            ;;
            
          "cleanup")
            echo "üßπ Cleaning up runtime analysis environment..."
            
            echo "### üßπ Cleanup Process" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Force cleanup any hanging processes
            pkill -f "kubectl port-forward" || true
            pkill -f "kind" || true
            
            # Check if we used an external cluster or Kind
            if [ "${{ inputs.use-external-cluster }}" = "true" ]; then
              echo "üîó Used external cluster - skipping cluster deletion..."
              echo "‚úÖ **External cluster preserved (no cleanup needed)**" >> $GITHUB_STEP_SUMMARY
              
              # Clean up our application deployments only
              kubectl delete deployment ${{ github.event.repository.name }} --ignore-not-found=true || true
              kubectl delete service ${{ github.event.repository.name }}-service --ignore-not-found=true || true
              echo "‚úÖ **Application resources cleaned up**" >> $GITHUB_STEP_SUMMARY
            else
              # Delete Kind cluster with timeout
              if command -v kind &> /dev/null; then
                echo "üóëÔ∏è Deleting Kind cluster..."
                timeout 60s kind delete cluster --name ${{ inputs.cluster-name }} || {
                  echo "‚ö†Ô∏è **Cluster deletion timed out, forcing cleanup...**" >> $GITHUB_STEP_SUMMARY
                  docker ps -a --filter "label=io.x-k8s.kind.cluster=${{ inputs.cluster-name }}" -q | xargs -r docker rm -f || true
                }
                echo "‚úÖ **Kind cluster cleanup attempted**" >> $GITHUB_STEP_SUMMARY
              fi
              
              # Clean up Docker networks
              docker network ls --filter "name=kind" -q | xargs -r docker network rm || true
              
              # Clean up any leftover containers
              docker ps -a --filter "label=io.x-k8s.kind.cluster" -q | xargs -r docker rm -f || true
            fi
            
            # Clean up temporary files
            rm -f kind-config.yaml app-deployment.yaml || true
            rm -f ~/.kube/config || true
            echo "‚úÖ **Temporary files cleaned up**" >> $GITHUB_STEP_SUMMARY
            
            echo "‚úÖ **Cleanup completed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            ;;
            
          *)
            echo "‚ùå Unknown action: ${{ inputs.action }}"
            exit 1
            ;;
        esac
